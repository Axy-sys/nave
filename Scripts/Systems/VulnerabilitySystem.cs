using Godot;
using CyberSecurityGame.Core.Events;
using System.Collections.Generic;

namespace CyberSecurityGame.Systems
{
	/// <summary>
	/// Sistema de vulnerabilidades y amenazas que aparecen durante el juego
	/// Mecánica educativa que enseña sobre tipos de vulnerabilidades
	/// </summary>
	public partial class VulnerabilitySystem : Node
	{
		private static VulnerabilitySystem _instance;
		public static VulnerabilitySystem Instance => _instance;

		[Export] public float VulnerabilitySpawnInterval = 30f; // Segundos
		
		private float _spawnTimer = 0f;
		private List<Vulnerability> _activeVulnerabilities;
		private List<VulnerabilityDefinition> _vulnerabilityDefinitions;

		public override void _Ready()
		{
			if (_instance != null && _instance != this)
			{
				QueueFree();
				return;
			}
			_instance = this;
			
			_activeVulnerabilities = new List<Vulnerability>();
			InitializeVulnerabilities();
		}

		public override void _Process(double delta)
		{
			_spawnTimer += (float)delta;
			
			if (_spawnTimer >= VulnerabilitySpawnInterval)
			{
				SpawnRandomVulnerability();
				_spawnTimer = 0f;
			}
		}

		private void InitializeVulnerabilities()
		{
			_vulnerabilityDefinitions = new List<VulnerabilityDefinition>
			{
				new VulnerabilityDefinition(
					"Puerto Abierto",
					"Puerto 443 expuesto sin cifrado",
					VulnerabilitySeverity.Medium,
                    "Cierra puertos innecesarios y usa HTTPS"
				),
				new VulnerabilityDefinition(
					"Software Desactualizado",
					"Sistema operativo sin parches de seguridad",
					VulnerabilitySeverity.High,
                    "Mantén siempre el software actualizado"
				),
				new VulnerabilityDefinition(
					"Credenciales Débiles",
					"Contraseña por defecto 'admin'",
					VulnerabilitySeverity.Critical,
                    "Cambia contraseñas por defecto inmediatamente"
				),
				new VulnerabilityDefinition(
					"Inyección XSS",
					"Validación de entrada insuficiente",
					VulnerabilitySeverity.High,
                    "Sanitiza todas las entradas de usuario"
				),
				new VulnerabilityDefinition(
					"Sesión Sin Expiración",
					"Tokens de sesión que nunca caducan",
					VulnerabilitySeverity.Medium,
                    "Implementa expiración de sesiones"
				),
				new VulnerabilityDefinition(
					"Datos Sin Cifrar",
					"Información sensible en texto plano",
					VulnerabilitySeverity.Critical,
                    "Cifra todos los datos sensibles"
				),
				new VulnerabilityDefinition(
					"CORS Mal Configurado",
					"Cross-Origin permite cualquier origen",
					VulnerabilitySeverity.Medium,
                    "Configura CORS solo para dominios confiables"
				),
				new VulnerabilityDefinition(
					"Logs Expuestos",
					"Archivos de log accesibles públicamente",
					VulnerabilitySeverity.Low,
                    "Protege archivos de log y logs sensibles"
				),
				new VulnerabilityDefinition(
					"Sin Rate Limiting",
					"API sin límite de peticiones",
					VulnerabilitySeverity.Medium,
                    "Implementa rate limiting en todas las APIs"
				),
				new VulnerabilityDefinition(
					"Dependencias Vulnerables",
					"Librerías con CVEs conocidos",
					VulnerabilitySeverity.High,
                    "Audita y actualiza dependencias regularmente"
				)
			};
		}

		private void SpawnRandomVulnerability()
		{
			var random = new System.Random();
			var definition = _vulnerabilityDefinitions[random.Next(_vulnerabilityDefinitions.Count)];
			
			var vulnerability = new Vulnerability(definition);
			_activeVulnerabilities.Add(vulnerability);
			
			GameEventBus.Instance.EmitVulnerabilityDetected(definition.Name);
			GD.Print($"⚠️ Vulnerabilidad detectada: {definition.Name} [{definition.Severity}]");
		}

		public void PatchVulnerability(Vulnerability vulnerability)
		{
			if (_activeVulnerabilities.Contains(vulnerability))
			{
				_activeVulnerabilities.Remove(vulnerability);
				GameEventBus.Instance.EmitThreatNeutralized(vulnerability.Definition.Name);
				
				// Recompensa por parchear vulnerabilidad
				int reward = vulnerability.Definition.Severity switch
				{
					VulnerabilitySeverity.Low => 100,
					VulnerabilitySeverity.Medium => 250,
					VulnerabilitySeverity.High => 500,
					VulnerabilitySeverity.Critical => 1000,
					_ => 50
				};
				
				GD.Print($"✅ Vulnerabilidad parcheada: {vulnerability.Definition.Name} (+{reward} pts)");
			}
		}

		public List<Vulnerability> GetActiveVulnerabilities()
		{
			return new List<Vulnerability>(_activeVulnerabilities);
		}
	}

	/// <summary>
	/// Definición de un tipo de vulnerabilidad
	/// </summary>
	public class VulnerabilityDefinition
	{
		public string Name { get; }
		public string Description { get; }
		public VulnerabilitySeverity Severity { get; }
		public string Solution { get; }

		public VulnerabilityDefinition(string name, string description, VulnerabilitySeverity severity, string solution)
		{
			Name = name;
			Description = description;
			Severity = severity;
			Solution = solution;
		}
	}

	/// <summary>
	/// Instancia de una vulnerabilidad activa
	/// </summary>
	public class Vulnerability
	{
		public VulnerabilityDefinition Definition { get; }
		public float TimeActive { get; set; }
		public bool IsPatched { get; set; }

		public Vulnerability(VulnerabilityDefinition definition)
		{
			Definition = definition;
			TimeActive = 0f;
			IsPatched = false;
		}
	}

	public enum VulnerabilitySeverity
	{
		Low,
		Medium,
		High,
		Critical
	}
}
